# 寻找两个正序数组的中位数  

### 给定两个大小为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的中位数。


### 进阶：你能设计一个时间复杂度为 O(log (m+n)) 的算法解决此问题吗？

### 示例 1：

输入：nums1 = [1,3], nums2 = [2]  
输出：2.00000  
解释：合并数组 = [1,2,3] ，中位数 2  
### 示例 2：

输入：nums1 = [1,2], nums2 = [3,4]  
输出：2.50000  
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
### 示例 3：
输入：nums1 = [0,0], nums2 = [0,0]  
输出：0.00000  
### 示例 4：
输入：nums1 = [], nums2 = [1]  
输出：1.00000
### 示例 5：
输入：nums1 = [2], nums2 = []  
输出：2.00000
 

### 提示：

nums1.length == m  
nums2.length == n  
0 <= m <= 1000  
0 <= n <= 1000  
1 <= m + n <= 2000  
-106 <= nums1[i], nums2[i] <= 106

### 解题思路：
如何把时间复杂度降低到`O(log(m+n))`呢？如果对时间复杂度的要求有`log`,通常都需要用到二分查找，
这道题也可以通过二分查找实现。

根据中位数的定义，当m+n是奇数时，中位数是两个有序数组中的第`(m+n)/2`个元素，当`m+n`是偶数时，
中位数是两个有序数组中的第`(m+n)/2`个元素和第`(m+n)/2+1`个元素的平均值。因此，这道题可以转化成
寻找两个有序数组中的第`k`小的数，其中`k`为`(m+n)/2`或`(m+n)/2+1`。

假设两个有序数组分别是`A` 和`B`。要找到第`k`个元素，我们可以比较`A[k/2−1]` 和`B[k/2−1]`，其中 `/` 表示整数除法。`A[k/2−1]`和
`B[k/2−1]` 的前面分别有`A[0..k/2−2]`和`B[0..k/2−2]`，即`k/2−1`个元素，对于`A[k/2−1]`和`B[k/2−1]`中的较小值，最多只会有
`(k/2−1)+(k/2−1)≤k−2` 个元素比它小，那么它就不能是第`k`小的数了。

因此我们可以归纳出三种情况：

如果`A[k/2−1]<B[k/2−1]`，则比`A[k/2−1]` 小的数最多只有`A` 的前`k/2−1` 个数和`B` 的前`k/2−1`个数，即比`A[k/2−1]`小的数最多只有`k−2`个，
因此 `A[k/2−1]` 不可能是第`k`个数，`A[0]` 到`A[k/2−1]` 也都不可能是第`k`个数，可以全部排除。

如果`A[k/2−1]>B[k/2−1]`，则可以排除`B[0]`到`B[k/2−1]`。

如果`A[k/2−1]=B[k/2−1]`，则可以归入第一种情况处理。

###来源：
力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays/

### 执行结果：
通过
显示详情 执行用时： 3 ms, 在所有 Java 提交中击败了 76.62%的用户
内存消耗：39.7 MB, 在所有 Java 提交中击败了 81.48% 的用户
